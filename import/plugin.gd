##
## import/plugin.gd
##
## `EditorImportPlugin` for `.baproto` schema files. Integrates with Godot's import
## system to automatically generate GDScript classes from Build-A-Proto schema files.
##

@tool
extends EditorImportPlugin

# -- DEPENDENCIES -------------------------------------------------------------------- #

const Platform := preload("./platform.gd")
const ProjectSetting := preload("./setting.gd")

# -- PRIVATE METHODS (OVERRIDES) ----------------------------------------------------- #


func _get_importer_name() -> String:
	return "baproto.schema"


func _get_visible_name() -> String:
	return "Build-A-Proto Schema"


func _get_recognized_extensions() -> PackedStringArray:
	return PackedStringArray(["baproto"])


func _get_save_extension() -> String:
	return "gd"


func _get_resource_type() -> String:
	return "Script"


func _get_priority() -> float:
	return 1.0


func _get_import_order() -> int:
	return 0


func _get_preset_count() -> int:
	return 0


func _get_import_options(_path: String, _preset: int) -> Array[Dictionary]:
	return []


func _import(
	source_file: String,
	save_path: String,
	_options: Dictionary,
	_platform_variants: Array[String],
	gen_files: Array[String]
) -> Error:
	# Step 1: Resolve binary path.
	var binary_path := Platform.resolve_binary_path()
	if binary_path.is_empty():
		push_error("[baproto] Binary not found; cannot import file: %s" % source_file)
		return ERR_FILE_NOT_FOUND

	# Step 2: Get output directory from ProjectSettings.
	var output_dir: String = ProjectSetting.output_directory().get_value()
	var output_dir_fs := ProjectSettings.globalize_path(output_dir)

	# Ensure output directory exists.
	var dir := DirAccess.open(output_dir_fs.get_base_dir())
	if dir == null:
		push_error(
			"[baproto] Cannot access parent directory of output: %s" % output_dir_fs
		)
		return ERR_FILE_CANT_OPEN

	if not DirAccess.dir_exists_absolute(output_dir_fs):
		var err := DirAccess.make_dir_recursive_absolute(output_dir_fs)
		if err != OK:
			push_error(
				(
					"[baproto] Failed to create output directory: %s (error %d)"
					% [output_dir_fs, err]
				)
			)
			return err

	# Step 3: Resolve import root for schema file resolution.
	var import_root_fs := ProjectSettings.globalize_path("res://")

	# Step 4: Prepare command arguments.
	var source_file_fs := ProjectSettings.globalize_path(source_file)
	var args := PackedStringArray(
		["generate", "-o", output_dir_fs, "-I", import_root_fs, source_file_fs]
	)

	# Step 5: Execute binary.
	var output: Array = []
	var exit_code := OS.execute(binary_path, args, output, true)

	# Step 6: Handle errors.
	if exit_code != 0:
		var error_msg := ""

		for line in output:
			error_msg += str(line)

		push_error("[baproto] Generation failed for %s: %s" % [source_file, error_msg])
		return ERR_COMPILATION_FAILED

	# Step 7: Collect generated files.
	var collected := _collect_generated_files(output_dir_fs)
	for file_path in collected:
		var res_path := ProjectSettings.localize_path(file_path)
		gen_files.append(res_path)

	# Step 8: Create save file (minimal stub required by 'EditorImportPlugin').
	var save_file_path := save_path + "." + _get_save_extension()
	var save_file := FileAccess.open(save_file_path, FileAccess.WRITE)
	if save_file == null:
		push_error("[baproto] Failed to create save file: %s" % save_file_path)
		return ERR_FILE_CANT_WRITE

	save_file.store_string(
		(
			"# DO NOT EDIT: Generated by baproto import plugin.\n"
			+ "# Source: %s\n" % source_file
			+ "# Generated files: %d\n" % gen_files.size()
		)
	)
	save_file.close()

	return OK


# -- PRIVATE METHODS ----------------------------------------------------------------- #


## `_collect_generated_files` recursively scans the output directory for all generated
## '.gd' files and returns their absolute filesystem paths.
func _collect_generated_files(dir_path: String) -> PackedStringArray:
	var result := PackedStringArray()
	var dir := DirAccess.open(dir_path)

	if dir == null:
		push_warning(
			"[baproto] Cannot open output directory for collection: %s" % dir_path
		)
		return result

	dir.list_dir_begin()
	var file_name := dir.get_next()

	while file_name != "":
		var full_path := dir_path.path_join(file_name)

		if dir.current_is_dir():
			if file_name != "." and file_name != "..":
				var subdir_files := _collect_generated_files(full_path)
				for subdir_file in subdir_files:
					result.append(subdir_file)

		elif file_name.ends_with(".gd"):
			result.append(full_path)

		file_name = dir.get_next()

	dir.list_dir_end()

	return result
