use baproto::{CodeWriter, Writer};
use derive_builder::Builder;

use super::Comment;
use super::Emit;
use super::Item;
use super::SectionHeader;

/* -------------------------------------------------------------------------- */
/*                               Struct: Script                               */
/* -------------------------------------------------------------------------- */

/// `Script` represents a complete GDScript file.
#[derive(Builder, Clone, Debug)]
pub struct Script {
    /// `header` is top-level file information (usually a warning to not edit).
    #[builder(
        default = "Script::generated_warning().into()",
        setter(into, strip_option)
    )]
    pub header: Option<Comment>,

    /// `comment` is a doc comment for the class.
    #[builder(default)]
    pub comment: Option<Comment>,

    /// `extends` is the GDScript class that this class inherits from.
    #[builder(setter(into))]
    pub extends: String,

    /// `class_name` is a global name for the class.
    #[builder(default)]
    pub class_name: Option<String>,

    /// `sections` is the content of the script file.
    #[builder(default)]
    pub sections: Vec<Section>,
}

/* ------------------------------ Impl: Script ------------------------------ */

impl Script {
    fn generated_warning() -> Comment {
        Comment {
            contents: vec![format!("DO NOT EDIT: Generated by baproto-gdscript")],
        }
    }
}

/* ------------------------------- Impl: Emit ------------------------------- */

impl Emit for Script {
    fn emit<W: Writer>(&self, cw: &mut CodeWriter, w: &mut W) -> anyhow::Result<()> {
        if let Some(comment) = self.header.as_ref() {
            comment.emit(cw, w)?;
            cw.newline(w)?;
        }

        if let Some(comment) = self.comment.as_ref() {
            comment.emit(cw, w)?;
        }

        if let Some(name) = self.class_name.as_ref() {
            cw.writeln(w, &format!("class_name {}", name))?;
        }

        cw.writeln(w, &format!("extends {}", self.extends))?;

        cw.blank_line(w)?;

        for section in &self.sections {
            section.emit(cw, w)?;
        }

        Ok(())
    }
}

/* -------------------------------------------------------------------------- */
/*                               Struct: Section                              */
/* -------------------------------------------------------------------------- */

/// `Section` represents a labeled code section with header comment.
#[derive(Clone, Debug, Builder)]
#[builder(setter(into))]
pub struct Section {
    pub header: SectionHeader,
    #[builder(default)]
    pub body: Vec<Item>,
}

/* ------------------------------- Impl: Emit ------------------------------- */

impl Emit for Section {
    fn emit<W: Writer>(&self, cw: &mut CodeWriter, w: &mut W) -> anyhow::Result<()> {
        self.header.emit(cw, w)?;
        cw.blank_line(w)?;

        // Emit body items.
        for item in &self.body {
            item.emit(cw, w)?;
        }

        // Trailing blank line after section.
        cw.blank_line(w)?;

        Ok(())
    }
}

/* -------------------------------------------------------------------------- */
/*                                 Mod: Tests                                 */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use baproto::StringWriter;

    use crate::gdscript::GDScript;

    use super::*;

    /* --------------------------- Tests: Section --------------------------- */

    #[test]
    fn test_section_empty_body() {
        // Given: A string to write to.
        let mut s = StringWriter::default();

        // Given: A code writer to write with.
        let mut cw = GDScript::writer();

        // Given: A section with empty body.
        let section = Section {
            header: SectionHeader::from("Constants"),
            body: vec![],
        };

        // When: The section is serialized to source code.
        let result = section.emit(&mut cw, &mut s);

        // Then: There was no error.
        assert!(result.is_ok());

        // Then: The output matches expectations.
        let expected = format!("# -- Constants {} #\n\n\n", "-".repeat(71));
        assert_eq!(s.into_content(), expected);
    }

    /* --------------------------- Tests: Script ---------------------------- */

    #[test]
    fn test_script_minimal() {
        // Given: A string to write to.
        let mut s = StringWriter::default();

        // Given: A code writer to write with.
        let mut cw = GDScript::writer();

        // Given: A minimal script.
        let script = Script {
            header: None,
            comment: None,
            extends: "Node".to_string(),
            class_name: None,
            sections: vec![],
        };

        // When: The script is serialized to source code.
        let result = script.emit(&mut cw, &mut s);

        // Then: There was no error.
        assert!(result.is_ok());

        // Then: The output matches expectations.
        assert_eq!(s.into_content(), "extends Node\n\n");
    }

    #[test]
    fn test_script_with_class_name() {
        // Given: A string to write to.
        let mut s = StringWriter::default();

        // Given: A code writer to write with.
        let mut cw = GDScript::writer();

        // Given: A script with class name.
        let script = Script {
            header: None,
            comment: None,
            extends: "Resource".to_string(),
            class_name: Some("MyResource".to_string()),
            sections: vec![],
        };

        // When: The script is serialized to source code.
        let result = script.emit(&mut cw, &mut s);

        // Then: There was no error.
        assert!(result.is_ok());

        // Then: The output matches expectations.
        assert_eq!(
            s.into_content(),
            "class_name MyResource\nextends Resource\n\n"
        );
    }

    #[test]
    fn test_script_with_generated_warning() {
        // Given: A string to write to.
        let mut s = StringWriter::default();

        // Given: A code writer to write with.
        let mut cw = GDScript::writer();

        // Given: A script with default generated warning.
        let script = ScriptBuilder::default()
            .extends("Node".to_string())
            .build()
            .unwrap();

        // When: The script is serialized to source code.
        let result = script.emit(&mut cw, &mut s);

        // Then: There was no error.
        assert!(result.is_ok());

        // Then: The output contains the warning.
        let content = s.into_content();
        assert!(content.contains("DO NOT EDIT: Generated by baproto-gdscript"));
        assert!(content.contains("extends Node"));
    }
}
