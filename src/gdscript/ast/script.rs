use baproto::{CodeWriter, Writer};
use derive_builder::Builder;

use super::Comment;
use super::Emit;
use super::Item;
use super::SectionHeader;

/* -------------------------------------------------------------------------- */
/*                               Struct: Script                               */
/* -------------------------------------------------------------------------- */

/// `Script` represents a complete GDScript file.
#[derive(Builder, Clone, Debug)]
pub struct Script {
    /// `header` is top-level file information (usually a warning to not edit).
    #[builder(default = "Script::generated_warning().into()")]
    pub header: Option<Comment>,

    /// `comment` is a doc comment for the class.
    #[builder(setter(into, strip_option))]
    pub comment: Option<Comment>,

    /// `extends` is the GDScript class that this class inherits from.
    pub extends: String,

    /// `class_name` is a global name for the class.
    #[builder(setter(into, strip_option))]
    pub class_name: Option<String>,

    /// `sections` is the content of the script file.
    #[builder(default)]
    pub sections: Vec<Section>,
}

/* ------------------------------ Impl: Script ------------------------------ */

impl Script {
    fn generated_warning() -> Comment {
        Comment {
            contents: vec![format!("DO NOT EDIT: Generated by baproto-gdscript")],
        }
    }
}

/* ------------------------------- Impl: Emit ------------------------------- */

impl Emit for Script {
    fn emit<W: Writer>(&self, cw: &mut CodeWriter, w: &mut W) -> anyhow::Result<()> {
        if let Some(comment) = self.header.as_ref() {
            comment.emit(cw, w)?;
            cw.blank_line(w)?;
        }

        if let Some(comment) = self.comment.as_ref() {
            comment.emit(cw, w)?;
        }

        if let Some(name) = self.class_name.as_ref() {
            cw.writeln(w, &format!("class_name {}", name))?;
        }

        cw.writeln(w, &format!("extends {}", self.extends))?;

        cw.blank_line(w)?;

        for section in &self.sections {
            section.emit(cw, w)?;
        }

        Ok(())
    }
}

/* -------------------------------------------------------------------------- */
/*                               Struct: Section                              */
/* -------------------------------------------------------------------------- */

/// `Section` represents a labeled code section with header comment.
#[derive(Clone, Debug, Builder)]
#[builder(setter(into))]
pub struct Section {
    pub header: SectionHeader,
    #[builder(default)]
    pub body: Vec<Item>,
}

/* ------------------------------- Impl: Emit ------------------------------- */

impl Emit for Section {
    fn emit<W: Writer>(&self, cw: &mut CodeWriter, w: &mut W) -> anyhow::Result<()> {
        self.header.emit(cw, w)?;
        cw.blank_line(w)?;

        // Emit body items.
        for item in &self.body {
            item.emit(cw, w)?;
        }

        // Trailing blank line after section.
        cw.blank_line(w)?;

        Ok(())
    }
}
