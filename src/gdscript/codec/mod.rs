/* ------------------------------- Mod: Decode ------------------------------ */

mod decode;
pub use decode::*;

/* ------------------------------- Mod: Encode ------------------------------ */

mod encode;
pub use encode::*;

/* ---------------------------- Mod: Enumeration ---------------------------- */

mod enumeration;
pub use enumeration::*;

/* -------------------------------- Mod: Wire ------------------------------- */

mod wire;

/* -------------------------------------------------------------------------- */
/*                                 Mod: Tests                                 */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod integration_tests {
    use std::path::Path;

    use baproto::*;

    use crate::gdscript::GDScript;

    /* ----------------------- Tests: codec_generation ---------------------- */

    #[test]
    fn test_codec_generation_for_primitive_fields() {
        // Given: A schema with a message containing primitive fields.
        let pkg = PackageName::try_from(vec!["test"]).unwrap();
        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg)
                        .path(vec!["Player".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![
                        Field {
                            name: "active".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::Bits { count: 1 },
                                native: NativeType::Bool,
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        },
                        Field {
                            name: "id".to_string(),
                            index: 1,
                            encoding: Encoding {
                                wire: WireFormat::Bits { count: 32 },
                                native: NativeType::Int {
                                    bits: 32,
                                    signed: false,
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        },
                        Field {
                            name: "score".to_string(),
                            index: 2,
                            encoding: Encoding {
                                wire: WireFormat::Bits { count: 32 },
                                native: NativeType::Float { bits: 32 },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        },
                        Field {
                            name: "name".to_string(),
                            index: 3,
                            encoding: Encoding {
                                wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                native: NativeType::String,
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        },
                    ],
                    messages: vec![],
                    enums: vec![],
                }],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Player message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/player.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var active: bool = false
var id: int = 0
var score: float = 0.0
var name: String = ""

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	_writer.write_bool(active)
	_writer.write_u32(id)
	_writer.write_f32(score)
	_writer.write_string(name)

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	active = _reader.read_bool()
	if _reader.get_error() != OK:
		return _reader.get_error()
	id = _reader.read_u32()
	if _reader.get_error() != OK:
		return _reader.get_error()
	score = _reader.read_f32()
	if _reader.get_error() != OK:
		return _reader.get_error()
	name = _reader.read_string()
	if _reader.get_error() != OK:
		return _reader.get_error()
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_codec_generation_for_bytes_field() {
        // Given: A schema with a message containing bytes field.
        let pkg = PackageName::try_from(vec!["test"]).unwrap();
        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg)
                        .path(vec!["Data".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![Field {
                        name: "payload".to_string(),
                        index: 0,
                        encoding: Encoding {
                            wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                            native: NativeType::Bytes,
                            transforms: vec![],
                            padding_bits: None,
                        },
                        doc: None,
                    }],
                    messages: vec![],
                    enums: vec![],
                }],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Data message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/data.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var payload: PackedByteArray = PackedByteArray()

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	_writer.write_varint_unsigned(payload.size())
	_writer.write_bytes(payload)

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	payload = _reader.read_bytes(_reader.read_varint_unsigned())
	if _reader.get_error() != OK:
		return _reader.get_error()
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_codec_generation_for_array_of_primitives() {
        // Given: A schema with a message containing array of integers.
        let pkg = PackageName::try_from(vec!["test"]).unwrap();
        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg)
                        .path(vec!["Stats".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![Field {
                        name: "scores".to_string(),
                        index: 0,
                        encoding: Encoding {
                            wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                            native: NativeType::Array {
                                element: Box::new(Encoding {
                                    wire: WireFormat::Bits { count: 32 },
                                    native: NativeType::Int {
                                        bits: 32,
                                        signed: true,
                                    },
                                    transforms: vec![],
                                    padding_bits: None,
                                }),
                            },
                            transforms: vec![],
                            padding_bits: None,
                        },
                        doc: None,
                    }],
                    messages: vec![],
                    enums: vec![],
                }],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Stats message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/stats.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var scores: Array[int] = []

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	_writer.write_varint_unsigned(scores.size())
	for _item in scores:
		_writer.write_i32(_item)

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	scores = []
	for _i in range(_reader.read_varint_unsigned()):
		_temp = _reader.read_i32()
		if _reader.get_error() != OK:
			return _reader.get_error()
		scores.append(_temp)
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_codec_generation_for_array_of_messages() {
        // Given: A schema with a message containing array of nested messages.
        let pkg = PackageName::try_from(vec!["test"]).unwrap();

        let item_descriptor = DescriptorBuilder::default()
            .package(pkg.clone())
            .path(vec!["Item".to_string()])
            .build()
            .unwrap();

        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![
                    Message {
                        descriptor: item_descriptor.clone(),
                        doc: None,
                        fields: vec![Field {
                            name: "value".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::Bits { count: 32 },
                                native: NativeType::Int {
                                    bits: 32,
                                    signed: false,
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        }],
                        messages: vec![],
                        enums: vec![],
                    },
                    Message {
                        descriptor: DescriptorBuilder::default()
                            .package(pkg)
                            .path(vec!["Container".to_string()])
                            .build()
                            .unwrap(),
                        doc: None,
                        fields: vec![Field {
                            name: "items".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                native: NativeType::Array {
                                    element: Box::new(Encoding {
                                        wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                        native: NativeType::Message {
                                            descriptor: item_descriptor,
                                        },
                                        transforms: vec![],
                                        padding_bits: None,
                                    }),
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        }],
                        messages: vec![],
                        enums: vec![],
                    },
                ],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Container message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/container.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")
const Item := preload("./item.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var items: Array[Item] = []

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	_writer.write_varint_unsigned(items.size())
	for _item in items:
		if _item == null:
			_writer.set_error(ERR_INVALID_DATA)
			return null
		_item._encode(_writer)

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	items = []
	for _i in range(_reader.read_varint_unsigned()):
		var _item := Item.new()
		_item._decode(_reader)
		if _reader.get_error() != OK:
			return _reader.get_error()
		items.append(_item)
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_codec_generation_for_map_with_primitive_values() {
        // Given: A schema with a message containing map (string -> int).
        let pkg = PackageName::try_from(vec!["test"]).unwrap();
        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg)
                        .path(vec!["Config".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![Field {
                        name: "settings".to_string(),
                        index: 0,
                        encoding: Encoding {
                            wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                            native: NativeType::Map {
                                key: Box::new(Encoding {
                                    wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                    native: NativeType::String,
                                    transforms: vec![],
                                    padding_bits: None,
                                }),
                                value: Box::new(Encoding {
                                    wire: WireFormat::Bits { count: 32 },
                                    native: NativeType::Int {
                                        bits: 32,
                                        signed: true,
                                    },
                                    transforms: vec![],
                                    padding_bits: None,
                                }),
                            },
                            transforms: vec![],
                            padding_bits: None,
                        },
                        doc: None,
                    }],
                    messages: vec![],
                    enums: vec![],
                }],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Config message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/config.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var settings: Dictionary = {}

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	_writer.write_varint_unsigned(settings.size())
	for _key in settings:
		_writer.write_string(_key)
		_writer.write_i32(settings[_key])

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	settings = {}
	for _i in range(_reader.read_varint_unsigned()):
		var _key := _reader.read_string()
		if _reader.get_error() != OK:
			return _reader.get_error()
		settings[_key] = _reader.read_i32()
		if _reader.get_error() != OK:
			return _reader.get_error()
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_codec_generation_for_map_with_message_values() {
        // Given: A schema with a message containing map (string -> Message).
        let pkg = PackageName::try_from(vec!["test"]).unwrap();

        let player_descriptor = DescriptorBuilder::default()
            .package(pkg.clone())
            .path(vec!["Player".to_string()])
            .build()
            .unwrap();

        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![
                    Message {
                        descriptor: player_descriptor.clone(),
                        doc: None,
                        fields: vec![Field {
                            name: "score".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::Bits { count: 32 },
                                native: NativeType::Int {
                                    bits: 32,
                                    signed: false,
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        }],
                        messages: vec![],
                        enums: vec![],
                    },
                    Message {
                        descriptor: DescriptorBuilder::default()
                            .package(pkg)
                            .path(vec!["Game".to_string()])
                            .build()
                            .unwrap(),
                        doc: None,
                        fields: vec![Field {
                            name: "players".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                native: NativeType::Map {
                                    key: Box::new(Encoding {
                                        wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                        native: NativeType::String,
                                        transforms: vec![],
                                        padding_bits: None,
                                    }),
                                    value: Box::new(Encoding {
                                        wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                        native: NativeType::Message {
                                            descriptor: player_descriptor,
                                        },
                                        transforms: vec![],
                                        padding_bits: None,
                                    }),
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        }],
                        messages: vec![],
                        enums: vec![],
                    },
                ],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Game message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/game.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")
const Player := preload("./player.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var players: Dictionary = {}

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	_writer.write_varint_unsigned(players.size())
	for _key in players:
		_writer.write_string(_key)
		var _value := players[_key]
		if _value == null:
			_writer.set_error(ERR_INVALID_DATA)
			return null
		_value._encode(_writer)

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	players = {}
	for _i in range(_reader.read_varint_unsigned()):
		var _key := _reader.read_string()
		if _reader.get_error() != OK:
			return _reader.get_error()
		var _value := Player.new()
		_value._decode(_reader)
		if _reader.get_error() != OK:
			return _reader.get_error()
		players[_key] = _value
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_codec_generation_for_nested_message_field() {
        // Given: A schema with a message containing another message as a field.
        let pkg = PackageName::try_from(vec!["test"]).unwrap();

        let stats_descriptor = DescriptorBuilder::default()
            .package(pkg.clone())
            .path(vec!["Stats".to_string()])
            .build()
            .unwrap();

        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![
                    Message {
                        descriptor: stats_descriptor.clone(),
                        doc: None,
                        fields: vec![Field {
                            name: "level".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::Bits { count: 32 },
                                native: NativeType::Int {
                                    bits: 32,
                                    signed: false,
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        }],
                        messages: vec![],
                        enums: vec![],
                    },
                    Message {
                        descriptor: DescriptorBuilder::default()
                            .package(pkg)
                            .path(vec!["Player".to_string()])
                            .build()
                            .unwrap(),
                        doc: None,
                        fields: vec![Field {
                            name: "stats".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                native: NativeType::Message {
                                    descriptor: stats_descriptor,
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        }],
                        messages: vec![],
                        enums: vec![],
                    },
                ],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Player message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/player.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")
const Stats := preload("./stats.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var stats: Stats = null

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	if stats == null:
		_writer.set_error(ERR_INVALID_DATA)
		return null
	stats._encode(_writer)

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	stats = Stats.new()
	stats._decode(_reader)
	if _reader.get_error() != OK:
		return _reader.get_error()
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_codec_generation_for_multiple_encoding_variations() {
        // Given: A schema with fields using different encoding variations.
        let pkg = PackageName::try_from(vec!["test"]).unwrap();
        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg)
                        .path(vec!["Encoded".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![
                        Field {
                            name: "varint_signed".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                native: NativeType::Int {
                                    bits: 64,
                                    signed: true,
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        },
                        Field {
                            name: "varint_unsigned".to_string(),
                            index: 1,
                            encoding: Encoding {
                                wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                native: NativeType::Int {
                                    bits: 64,
                                    signed: false,
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        },
                        Field {
                            name: "zigzag".to_string(),
                            index: 2,
                            encoding: Encoding {
                                wire: WireFormat::Bits { count: 16 },
                                native: NativeType::Int {
                                    bits: 16,
                                    signed: true,
                                },
                                transforms: vec![Transform::ZigZag],
                                padding_bits: None,
                            },
                            doc: None,
                        },
                    ],
                    messages: vec![],
                    enums: vec![],
                }],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Encoded message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/encoded.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var varint_signed: int = 0
var varint_unsigned: int = 0
var zigzag: int = 0

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	_writer.write_varint_signed(varint_signed)
	_writer.write_varint_unsigned(varint_unsigned)
	_writer.write_zigzag(zigzag, 16)

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	varint_signed = _reader.read_varint_signed()
	if _reader.get_error() != OK:
		return _reader.get_error()
	varint_unsigned = _reader.read_varint_unsigned()
	if _reader.get_error() != OK:
		return _reader.get_error()
	zigzag = _reader.read_zigzag(16)
	if _reader.get_error() != OK:
		return _reader.get_error()
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_codec_generation_for_complex_schema() {
        // Given: A schema with a message containing multiple field types.
        let pkg = PackageName::try_from(vec!["test"]).unwrap();

        let item_descriptor = DescriptorBuilder::default()
            .package(pkg.clone())
            .path(vec!["Item".to_string()])
            .build()
            .unwrap();

        let schema = Schema {
            packages: vec![Package {
                name: pkg.clone(),
                messages: vec![
                    Message {
                        descriptor: item_descriptor.clone(),
                        doc: None,
                        fields: vec![Field {
                            name: "id".to_string(),
                            index: 0,
                            encoding: Encoding {
                                wire: WireFormat::Bits { count: 32 },
                                native: NativeType::Int {
                                    bits: 32,
                                    signed: false,
                                },
                                transforms: vec![],
                                padding_bits: None,
                            },
                            doc: None,
                        }],
                        messages: vec![],
                        enums: vec![],
                    },
                    Message {
                        descriptor: DescriptorBuilder::default()
                            .package(pkg)
                            .path(vec!["Complex".to_string()])
                            .build()
                            .unwrap(),
                        doc: None,
                        fields: vec![
                            Field {
                                name: "enabled".to_string(),
                                index: 0,
                                encoding: Encoding {
                                    wire: WireFormat::Bits { count: 1 },
                                    native: NativeType::Bool,
                                    transforms: vec![],
                                    padding_bits: None,
                                },
                                doc: None,
                            },
                            Field {
                                name: "data".to_string(),
                                index: 1,
                                encoding: Encoding {
                                    wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                    native: NativeType::Bytes,
                                    transforms: vec![],
                                    padding_bits: None,
                                },
                                doc: None,
                            },
                            Field {
                                name: "values".to_string(),
                                index: 2,
                                encoding: Encoding {
                                    wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                    native: NativeType::Array {
                                        element: Box::new(Encoding {
                                            wire: WireFormat::Bits { count: 32 },
                                            native: NativeType::Int {
                                                bits: 32,
                                                signed: true,
                                            },
                                            transforms: vec![],
                                            padding_bits: None,
                                        }),
                                    },
                                    transforms: vec![],
                                    padding_bits: None,
                                },
                                doc: None,
                            },
                            Field {
                                name: "items".to_string(),
                                index: 3,
                                encoding: Encoding {
                                    wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                    native: NativeType::Array {
                                        element: Box::new(Encoding {
                                            wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                            native: NativeType::Message {
                                                descriptor: item_descriptor.clone(),
                                            },
                                            transforms: vec![],
                                            padding_bits: None,
                                        }),
                                    },
                                    transforms: vec![],
                                    padding_bits: None,
                                },
                                doc: None,
                            },
                            Field {
                                name: "metadata".to_string(),
                                index: 4,
                                encoding: Encoding {
                                    wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                    native: NativeType::Map {
                                        key: Box::new(Encoding {
                                            wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                            native: NativeType::String,
                                            transforms: vec![],
                                            padding_bits: None,
                                        }),
                                        value: Box::new(Encoding {
                                            wire: WireFormat::Bits { count: 32 },
                                            native: NativeType::Int {
                                                bits: 32,
                                                signed: false,
                                            },
                                            transforms: vec![],
                                            padding_bits: None,
                                        }),
                                    },
                                    transforms: vec![],
                                    padding_bits: None,
                                },
                                doc: None,
                            },
                            Field {
                                name: "nested".to_string(),
                                index: 5,
                                encoding: Encoding {
                                    wire: WireFormat::LengthPrefixed { prefix_bits: 64 },
                                    native: NativeType::Message {
                                        descriptor: item_descriptor,
                                    },
                                    transforms: vec![],
                                    padding_bits: None,
                                },
                                doc: None,
                            },
                        ],
                        messages: vec![],
                        enums: vec![],
                    },
                ],
                enums: vec![],
            }],
        };

        // When: Generating GDScript code.
        let output = GDScript.generate(&schema).unwrap();

        // Then: The Complex message file matches expected content exactly.
        let actual = output.files.get(Path::new("test/complex.gd")).unwrap();

        let expected = r#"## DO NOT EDIT: Generated by 'baproto-gdscript'

extends RefCounted

# -- DEPENDENCIES -------------------------------------------------------------------- #

const _Reader := preload("res://addons/baproto/runtime/reader.gd")
const _Writer := preload("res://addons/baproto/runtime/writer.gd")
const Item := preload("./item.gd")

# -- TYPES --------------------------------------------------------------------------- #


# -- INITIALIZATION ------------------------------------------------------------------ #

var enabled: bool = false
var data: PackedByteArray = PackedByteArray()
var values: Array[int] = []
var items: Array[Item] = []
var metadata: Dictionary = {}
var nested: Item = null

# -- PUBLIC METHODS ------------------------------------------------------------------ #

## `serialize` writes this message to a `PackedByteArray`.
func serialize(out: PackedByteArray) -> Error:
	var _writer := _Writer.new()
	_encode(_writer)
	out.append_array(_writer.to_bytes())
	return _writer.get_error()

## `deserialize` reads this message from a `PackedByteArray`.
func deserialize(data: PackedByteArray) -> Error:
	var _reader := _Reader.new(data)
	_decode(_reader)
	return _reader.get_error()

# -- PRIVATE METHODS ----------------------------------------------------------------- #

## `_encode` serializes fields to the writer.
func _encode(_writer: _Writer) -> void:
	_writer.write_bool(enabled)
	_writer.write_varint_unsigned(data.size())
	_writer.write_bytes(data)
	_writer.write_varint_unsigned(values.size())
	for _item in values:
		_writer.write_i32(_item)
	_writer.write_varint_unsigned(items.size())
	for _item in items:
		if _item == null:
			_writer.set_error(ERR_INVALID_DATA)
			return null
		_item._encode(_writer)
	_writer.write_varint_unsigned(metadata.size())
	for _key in metadata:
		_writer.write_string(_key)
		_writer.write_u32(metadata[_key])
	if nested == null:
		_writer.set_error(ERR_INVALID_DATA)
		return null
	nested._encode(_writer)

## `_decode` deserializes fields from the reader.
func _decode(_reader: _Reader) -> Error:
	enabled = _reader.read_bool()
	if _reader.get_error() != OK:
		return _reader.get_error()
	data = _reader.read_bytes(_reader.read_varint_unsigned())
	if _reader.get_error() != OK:
		return _reader.get_error()
	values = []
	for _i in range(_reader.read_varint_unsigned()):
		_temp = _reader.read_i32()
		if _reader.get_error() != OK:
			return _reader.get_error()
		values.append(_temp)
	items = []
	for _i in range(_reader.read_varint_unsigned()):
		var _item := Item.new()
		_item._decode(_reader)
		if _reader.get_error() != OK:
			return _reader.get_error()
		items.append(_item)
	metadata = {}
	for _i in range(_reader.read_varint_unsigned()):
		var _key := _reader.read_string()
		if _reader.get_error() != OK:
			return _reader.get_error()
		metadata[_key] = _reader.read_u32()
		if _reader.get_error() != OK:
			return _reader.get_error()
	nested = Item.new()
	nested._decode(_reader)
	if _reader.get_error() != OK:
		return _reader.get_error()
	return _reader.get_error()

"#;

        assert_eq!(actual, expected);
    }
}
