use baproto::{CodeWriter, Enum, StringWriter, Variant, Writer};

use crate::gdscript::collect::TypeEntry;
use crate::gdscript::types::escape_keyword;

/* -------------------------------------------------------------------------- */
/*                              Fn: generate_enum                             */
/* -------------------------------------------------------------------------- */

/// `generate_enum` generates the GDScript code for an enum type.
///
/// Enums are represented as classes with integer constants, since GDScript
/// doesn't support standalone enums. The class is non-instantiable.
pub fn generate_enum(
    cw: &mut CodeWriter,
    enm: &Enum,
    _entry: &TypeEntry,
) -> anyhow::Result<String> {
    let mut w = StringWriter::default();

    // Header comment.
    cw.comment(&mut w, "DO NOT EDIT: Generated by baproto-gdscript")?;
    cw.blank_line(&mut w)?;

    // Doc comment if present.
    if let Some(doc) = &enm.doc {
        cw.comment_block(&mut w, doc)?;
    }

    // Extends RefCounted.
    cw.writeln(&mut w, "extends RefCounted")?;
    cw.blank_line(&mut w)?;

    // Constants section.
    if !enm.variants.is_empty() {
        write_constants_section(cw, &mut w, &enm.variants)?;
    }

    // Engine methods section (non-instantiable).
    write_engine_methods_section(cw, &mut w, enm.name().unwrap_or("Enum"))?;

    Ok(w.into_content())
}

/* ----------------------- Fn: write_constants_section ---------------------- */

/// `write_constants_section` writes the enum constants section.
fn write_constants_section<W: Writer>(
    cw: &mut CodeWriter,
    w: &mut W,
    variants: &[Variant],
) -> anyhow::Result<()> {
    cw.comment(
        w,
        "-- CONSTANTS ----------------------------------------------------------------------- #",
    )?;
    cw.blank_line(w)?;

    for variant in variants {
        match variant {
            Variant::Unit { name, index, doc } => {
                cw.comment_opt(w, doc.as_deref())?;
                let escaped_name = escape_keyword(name);
                cw.writeln(w, &format!("const {}: int = {}", escaped_name, index))?;
            }
            Variant::Field {
                name, index, doc, ..
            } => {
                // For field variants, we still generate the discriminant constant.
                // The associated data handling would be done separately.
                cw.comment_opt(w, doc.as_deref())?;
                let escaped_name = escape_keyword(name);
                cw.writeln(w, &format!("const {}: int = {}", escaped_name, index))?;
            }
        }
    }

    cw.blank_line(w)?;
    Ok(())
}

/* -------------------- Fn: write_engine_methods_section -------------------- */

/// `write_engine_methods_section` writes the _init method that prevents instantiation.
fn write_engine_methods_section<W: Writer>(
    cw: &mut CodeWriter,
    w: &mut W,
    name: &str,
) -> anyhow::Result<()> {
    cw.comment(
        w,
        "-- ENGINE METHODS (OVERRIDES) ------------------------------------------------------ #",
    )?;
    cw.blank_line(w)?;

    cw.writeln(w, "func _init() -> void:")?;
    cw.indent();
    cw.writeln(
        w,
        &format!("assert(false, \"{} is non-instantiable\")", name),
    )?;
    cw.outdent();

    Ok(())
}

/* -------------------------------------------------------------------------- */
/*                                 Mod: Tests                                 */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use crate::gdscript::collect::TypeKind;
    use baproto::{
        CodeWriterBuilder, DescriptorBuilder, Encoding, NativeType, PackageName, WireFormat,
    };

    /* ------------------------ Tests: generate_enum ------------------------ */

    #[test]
    fn test_generate_empty_enum() {
        // Given: An empty enum.
        let enm = create_test_enum("State", vec![]);
        let entry = TypeEntry {
            kind: TypeKind::Enum(enm.clone()),
            file_stem: "State".to_string(),
            simple_name: "State".to_string(),
            nested: vec![],
        };

        // When: Generating the enum.
        let mut cw = create_code_writer();
        let result = generate_enum(&mut cw, &enm, &entry).unwrap();

        // Then: Output should contain header and base class.
        assert!(result.contains("## DO NOT EDIT: Generated by baproto-gdscript"));
        assert!(result.contains("extends RefCounted"));
        assert!(result.contains("func _init() -> void:"));
        assert!(result.contains("State is non-instantiable"));
    }

    #[test]
    fn test_generate_enum_with_variants() {
        // Given: An enum with unit variants.
        let enm = create_test_enum(
            "State",
            vec![
                Variant::Unit {
                    name: "IDLE".to_string(),
                    index: 0,
                    doc: None,
                },
                Variant::Unit {
                    name: "MOVING".to_string(),
                    index: 1,
                    doc: Some("The moving state.".to_string()),
                },
                Variant::Unit {
                    name: "JUMPING".to_string(),
                    index: 2,
                    doc: None,
                },
            ],
        );
        let entry = TypeEntry {
            kind: TypeKind::Enum(enm.clone()),
            file_stem: "State".to_string(),
            simple_name: "State".to_string(),
            nested: vec![],
        };

        // When: Generating the enum.
        let mut cw = create_code_writer();
        let result = generate_enum(&mut cw, &enm, &entry).unwrap();

        // Then: Output should contain the constants.
        assert!(result.contains("const IDLE: int = 0"));
        assert!(result.contains("const MOVING: int = 1"));
        assert!(result.contains("const JUMPING: int = 2"));
        assert!(result.contains("## The moving state."));
    }

    #[test]
    fn test_generate_enum_with_doc() {
        // Given: An enum with a doc comment.
        let mut enm = create_test_enum("State", vec![]);
        enm.doc = Some("Represents the entity state.".to_string());
        let entry = TypeEntry {
            kind: TypeKind::Enum(enm.clone()),
            file_stem: "State".to_string(),
            simple_name: "State".to_string(),
            nested: vec![],
        };

        // When: Generating the enum.
        let mut cw = create_code_writer();
        let result = generate_enum(&mut cw, &enm, &entry).unwrap();

        // Then: Output should contain the doc comment.
        assert!(result.contains("## Represents the entity state."));
    }

    #[test]
    fn test_generate_enum_escapes_keywords() {
        // Given: An enum with a variant named after a keyword.
        let enm = create_test_enum(
            "Mode",
            vec![Variant::Unit {
                name: "class".to_string(),
                index: 0,
                doc: None,
            }],
        );
        let entry = TypeEntry {
            kind: TypeKind::Enum(enm.clone()),
            file_stem: "Mode".to_string(),
            simple_name: "Mode".to_string(),
            nested: vec![],
        };

        // When: Generating the enum.
        let mut cw = create_code_writer();
        let result = generate_enum(&mut cw, &enm, &entry).unwrap();

        // Then: The keyword should be escaped.
        assert!(result.contains("const class_: int = 0"));
    }

    /* ----------------------- Fn: create_code_writer ----------------------- */

    fn create_code_writer() -> CodeWriter {
        CodeWriterBuilder::default()
            .comment_token("##".to_owned())
            .indent_token("\t".to_owned())
            .newline_token("\n".to_owned())
            .build()
            .unwrap()
    }

    /* ------------------------ Fn: create_test_enum ------------------------ */

    fn create_test_enum(name: &str, variants: Vec<Variant>) -> Enum {
        Enum {
            descriptor: DescriptorBuilder::default()
                .package(PackageName::try_from(vec!["test"]).unwrap())
                .path(vec![name.to_string()])
                .build()
                .unwrap(),
            discriminant: Encoding {
                wire: WireFormat::Bits { count: 8 },
                native: NativeType::Int {
                    bits: 8,
                    signed: false,
                },
                transforms: vec![],
                padding_bits: None,
            },
            doc: None,
            variants,
        }
    }
}
