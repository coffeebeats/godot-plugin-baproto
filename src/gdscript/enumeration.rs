use baproto::{CodeWriter, Enum, StringWriter, Variant};

use crate::gdscript::ast::{Emit, FuncDeclBuilder, GDFileBuilder, Item, SectionBuilder, Stmt};
use crate::gdscript::collect::TypeEntry;
use crate::gdscript::types::escape_keyword;

/* -------------------------------------------------------------------------- */
/*                              Fn: generate_enum                             */
/* -------------------------------------------------------------------------- */

/// `generate_enum` generates the GDScript code for an enum type.
///
/// Enums are represented as classes with integer constants, since GDScript
/// doesn't support standalone enums. The class is non-instantiable.
pub fn generate_enum(
    cw: &mut CodeWriter,
    enm: &Enum,
    _entry: &TypeEntry,
) -> anyhow::Result<String> {
    let mut w = StringWriter::default();

    // Build sections.
    let mut sections = Vec::new();

    // CONSTANTS section.
    if !enm.variants.is_empty() {
        let mut items = Vec::new();
        for variant in &enm.variants {
            match variant {
                Variant::Unit { name, index, doc } => {
                    let escaped_name = escape_keyword(name);
                    items.push(Item::Stmt(Stmt::Const {
                        name: escaped_name,
                        type_hint: Some("int".to_string()),
                        value: index.to_string(),
                        doc: doc.clone(),
                    }));
                }
                Variant::Field {
                    name, index, doc, ..
                } => {
                    // For field variants, we still generate the discriminant constant.
                    // The associated data handling would be done separately.
                    let escaped_name = escape_keyword(name);
                    items.push(Item::Stmt(Stmt::Const {
                        name: escaped_name,
                        type_hint: Some("int".to_string()),
                        value: index.to_string(),
                        doc: doc.clone(),
                    }));
                }
            }
        }

        sections.push(
            SectionBuilder::default()
                .name("CONSTANTS")
                .body(items)
                .build()?,
        );
    }

    // ENGINE METHODS section (non-instantiable).
    let enum_name = enm.name().unwrap_or("Enum");
    let init_func = FuncDeclBuilder::default()
        .name("_init")
        .return_type("void")
        .body(vec![Stmt::Expr(format!(
            "assert(false, \"{} is non-instantiable\")",
            enum_name
        ))])
        .build()?;

    sections.push(
        SectionBuilder::default()
            .name("ENGINE METHODS (OVERRIDES)")
            .body(vec![Item::Func(init_func)])
            .build()?,
    );

    // Build the GDScript file.
    let mut builder = GDFileBuilder::default();
    builder
        .header_comment("DO NOT EDIT: Generated by baproto-gdscript")
        .extends("RefCounted")
        .sections(sections);

    if let Some(doc) = &enm.doc {
        builder.doc(doc.clone());
    }

    let file = builder.build()?;

    // Emit the file.
    file.emit(cw, &mut w)?;

    Ok(w.into_content())
}

/* -------------------------------------------------------------------------- */
/*                                 Mod: Tests                                 */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use crate::gdscript::collect::TypeKind;
    use crate::gdscript::tests::create_code_writer;
    use baproto::{DescriptorBuilder, Encoding, NativeType, PackageName, Variant, WireFormat};

    /* ------------------------ Tests: generate_enum ------------------------ */

    #[test]
    fn test_generate_empty_enum() {
        // Given: An empty enum.
        let enm = create_test_enum("State", vec![]);
        let entry = TypeEntry {
            kind: TypeKind::Enum(enm.clone()),
            file_stem: "State".to_string(),
            simple_name: "State".to_string(),
            nested: vec![],
        };

        // When: Generating the enum.
        let mut cw = create_code_writer();
        let result = generate_enum(&mut cw, &enm, &entry).unwrap();

        // Then: Output should contain header and base class.
        assert!(result.contains("## DO NOT EDIT: Generated by baproto-gdscript"));
        assert!(result.contains("extends RefCounted"));
        assert!(result.contains("func _init() -> void:"));
        assert!(result.contains("State is non-instantiable"));
    }

    #[test]
    fn test_generate_enum_with_variants() {
        // Given: An enum with unit variants.
        let enm = create_test_enum(
            "State",
            vec![
                Variant::Unit {
                    name: "IDLE".to_string(),
                    index: 0,
                    doc: None,
                },
                Variant::Unit {
                    name: "MOVING".to_string(),
                    index: 1,
                    doc: Some("The moving state.".to_string()),
                },
                Variant::Unit {
                    name: "JUMPING".to_string(),
                    index: 2,
                    doc: None,
                },
            ],
        );
        let entry = TypeEntry {
            kind: TypeKind::Enum(enm.clone()),
            file_stem: "State".to_string(),
            simple_name: "State".to_string(),
            nested: vec![],
        };

        // When: Generating the enum.
        let mut cw = create_code_writer();
        let result = generate_enum(&mut cw, &enm, &entry).unwrap();

        // Then: Output should contain the constants.
        assert!(result.contains("const IDLE: int = 0"));
        assert!(result.contains("const MOVING: int = 1"));
        assert!(result.contains("const JUMPING: int = 2"));
        assert!(result.contains("## The moving state."));
    }

    #[test]
    fn test_generate_enum_with_doc() {
        // Given: An enum with a doc comment.
        let mut enm = create_test_enum("State", vec![]);
        enm.doc = Some("Represents the entity state.".to_string());
        let entry = TypeEntry {
            kind: TypeKind::Enum(enm.clone()),
            file_stem: "State".to_string(),
            simple_name: "State".to_string(),
            nested: vec![],
        };

        // When: Generating the enum.
        let mut cw = create_code_writer();
        let result = generate_enum(&mut cw, &enm, &entry).unwrap();

        // Then: Output should contain the doc comment.
        assert!(result.contains("## Represents the entity state."));
    }

    #[test]
    fn test_generate_enum_escapes_keywords() {
        // Given: An enum with a variant named after a keyword.
        let enm = create_test_enum(
            "Mode",
            vec![Variant::Unit {
                name: "class".to_string(),
                index: 0,
                doc: None,
            }],
        );
        let entry = TypeEntry {
            kind: TypeKind::Enum(enm.clone()),
            file_stem: "Mode".to_string(),
            simple_name: "Mode".to_string(),
            nested: vec![],
        };

        // When: Generating the enum.
        let mut cw = create_code_writer();
        let result = generate_enum(&mut cw, &enm, &entry).unwrap();

        // Then: The keyword should be escaped.
        assert!(result.contains("const class_: int = 0"));
    }

    /* ------------------------ Fn: create_test_enum ------------------------ */

    fn create_test_enum(name: &str, variants: Vec<Variant>) -> Enum {
        Enum {
            descriptor: DescriptorBuilder::default()
                .package(PackageName::try_from(vec!["test"]).unwrap())
                .path(vec![name.to_string()])
                .build()
                .unwrap(),
            discriminant: Encoding {
                wire: WireFormat::Bits { count: 8 },
                native: NativeType::Int {
                    bits: 8,
                    signed: false,
                },
                transforms: vec![],
                padding_bits: None,
            },
            doc: None,
            variants,
        }
    }
}
