use baproto::{CodeWriter, Message, StringWriter, Writer};

use crate::gdscript::collect::TypeEntry;
use crate::gdscript::types::{
    collect_field_dependencies, default_value, escape_keyword, type_name,
};

/* -------------------------------------------------------------------------- */
/*                            Fn: generate_message                            */
/* -------------------------------------------------------------------------- */

/// `generate_message` generates the GDScript code for a message type.
pub fn generate_message(
    cw: &mut CodeWriter,
    msg: &Message,
    entry: &TypeEntry,
    pkg: &[String],
) -> anyhow::Result<String> {
    let mut w = StringWriter::default();

    // Header comment.
    cw.comment(&mut w, "DO NOT EDIT: Generated by baproto-gdscript")?;
    cw.blank_line(&mut w)?;

    // Doc comment if present.
    if let Some(doc) = &msg.doc {
        cw.comment_block(&mut w, doc)?;
    }

    // Extends RefCounted.
    cw.writeln(&mut w, "extends RefCounted")?;
    cw.blank_line(&mut w)?;

    // Collect dependencies (external message/enum types used in fields).
    let deps = collect_field_dependencies(&msg.fields, pkg, &entry.file_stem);

    // Dependencies section.
    if !deps.is_empty() || !entry.nested.is_empty() {
        write_dependencies_section(cw, &mut w, &deps, &entry.nested, &entry.file_stem)?;
    }

    // Fields section.
    if !msg.fields.is_empty() {
        write_fields_section(cw, &mut w, &msg.fields)?;
    }

    // Public methods section.
    write_public_methods_section(cw, &mut w)?;

    Ok(w.into_content())
}

/* --------------------- Fn: write_dependencies_section --------------------- */

/// `write_dependencies_section` writes the dependencies (preloads) section.
fn write_dependencies_section<W: Writer>(
    cw: &mut CodeWriter,
    w: &mut W,
    deps: &[(String, String, String)],
    nested: &[String],
    file_stem: &str,
) -> anyhow::Result<()> {
    cw.comment(
        w,
        "-- DEPENDENCIES -------------------------------------------------------------------- #",
    )?;
    cw.blank_line(w)?;

    // External dependencies.
    for (const_name, _file_stem, path) in deps {
        cw.writeln(w, &format!("const {} := preload(\"{}\")", const_name, path))?;
    }

    // Nested type references.
    if !nested.is_empty() {
        if !deps.is_empty() {
            cw.blank_line(w)?;
        }
        cw.comment(
            w,
            "-- NESTED TYPES -------------------------------------------------------------------- #",
        )?;
        cw.blank_line(w)?;

        for nested_stem in nested {
            // Extract the simple name from the nested file stem.
            let simple_name = nested_stem
                .strip_prefix(&format!("{}_", file_stem))
                .unwrap_or(nested_stem);
            cw.writeln(
                w,
                &format!("const {} := preload(\"./{}.gd\")", simple_name, nested_stem),
            )?;
        }
    }

    cw.blank_line(w)?;
    Ok(())
}

/* ------------------------ Fn: write_fields_section ------------------------ */

/// `write_fields_section` writes the fields section.
fn write_fields_section<W: Writer>(
    cw: &mut CodeWriter,
    w: &mut W,
    fields: &[baproto::Field],
) -> anyhow::Result<()> {
    cw.comment(
        w,
        "-- FIELDS -------------------------------------------------------------------------- #",
    )?;
    cw.blank_line(w)?;

    for field in fields {
        // Doc comment.
        cw.comment_opt(w, field.doc.as_deref())?;

        let name = escape_keyword(&field.name);
        let type_str = type_name(&field.encoding.native);
        let default = default_value(&field.encoding.native);

        cw.writeln(w, &format!("var {}: {} = {}", name, type_str, default))?;
    }

    cw.blank_line(w)?;
    Ok(())
}

/* -------------------- Fn: write_public_methods_section -------------------- */

/// `write_public_methods_section` writes the encode/decode method stubs.
fn write_public_methods_section<W: Writer>(cw: &mut CodeWriter, w: &mut W) -> anyhow::Result<()> {
    cw.comment(
        w,
        "-- PUBLIC METHODS ------------------------------------------------------------------ #",
    )?;
    cw.blank_line(w)?;

    // Encode method.
    cw.comment(
        w,
        "`encode` serializes this message to the provided writer.",
    )?;
    cw.writeln(w, "func encode(_writer) -> void:")?;
    cw.indent();
    cw.writeln(w, "pass  # TODO: Implement serialization")?;
    cw.outdent();
    cw.blank_line(w)?;

    // Decode method.
    cw.comment(
        w,
        "`decode` deserializes a message from the provided reader.",
    )?;
    cw.writeln(w, "static func decode(_reader):")?;
    cw.indent();
    cw.writeln(w, "return null  # TODO: Implement deserialization")?;
    cw.outdent();

    Ok(())
}

/* -------------------------------------------------------------------------- */
/*                                 Mod: Tests                                 */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use crate::gdscript::tests::create_code_writer;
    use baproto::{Encoding, NativeType, WireFormat};

    /* ------------------------ Tests: generate_message ----------------------- */

    // Note: Full integration tests that require constructing Message/Enum with
    // Descriptors are in `mod.rs` where we use the `Generator::generate`
    // method. These unit tests focus on the helper functions and code writer
    // behavior.

    #[test]
    fn test_write_fields_section() {
        // Given: A list of fields.
        let fields = vec![
            baproto::Field {
                name: "health".to_string(),
                index: 0,
                encoding: Encoding {
                    wire: WireFormat::Bits { count: 32 },
                    native: NativeType::Int {
                        bits: 32,
                        signed: true,
                    },
                    transforms: vec![],
                    padding_bits: None,
                },
                doc: Some("The player's health.".to_string()),
            },
            baproto::Field {
                name: "name".to_string(),
                index: 1,
                encoding: Encoding {
                    wire: WireFormat::LengthPrefixed { prefix_bits: 16 },
                    native: NativeType::String,
                    transforms: vec![],
                    padding_bits: None,
                },
                doc: None,
            },
        ];

        // When: Writing the fields section.
        let mut cw = create_code_writer();
        let mut w = StringWriter::default();
        write_fields_section(&mut cw, &mut w, &fields).unwrap();

        let result = w.into_content();

        // Then: Output should contain the fields with types and defaults.
        assert!(result.contains("var health: int = 0"));
        assert!(result.contains("var name: String = \"\""));
        assert!(result.contains("## The player's health."));
    }

    #[test]
    fn test_write_fields_section_escapes_keywords() {
        // Given: A field named after a keyword.
        let fields = vec![baproto::Field {
            name: "class".to_string(),
            index: 0,
            encoding: Encoding {
                wire: WireFormat::LengthPrefixed { prefix_bits: 16 },
                native: NativeType::String,
                transforms: vec![],
                padding_bits: None,
            },
            doc: None,
        }];

        // When: Writing the fields section.
        let mut cw = create_code_writer();
        let mut w = StringWriter::default();
        write_fields_section(&mut cw, &mut w, &fields).unwrap();

        let result = w.into_content();

        // Then: The keyword should be escaped.
        assert!(result.contains("var class_: String = \"\""));
    }

    #[test]
    fn test_write_dependencies_section_with_nested() {
        // Given: Some nested types.
        let deps: Vec<(String, String, String)> = vec![];
        let nested = vec!["Player_Stats".to_string(), "Player_State".to_string()];
        let file_stem = "Player";

        // When: Writing the dependencies section.
        let mut cw = create_code_writer();
        let mut w = StringWriter::default();
        write_dependencies_section(&mut cw, &mut w, &deps, &nested, file_stem).unwrap();

        let result = w.into_content();

        // Then: Output should contain nested type preloads.
        assert!(result.contains("const Stats := preload(\"./Player_Stats.gd\")"));
        assert!(result.contains("const State := preload(\"./Player_State.gd\")"));
    }

    #[test]
    fn test_write_public_methods_section() {
        // Given: A code writer.
        let mut cw = create_code_writer();
        let mut w = StringWriter::default();

        // When: Writing the public methods section.
        write_public_methods_section(&mut cw, &mut w).unwrap();

        let result = w.into_content();

        // Then: Output should contain encode and decode stubs.
        assert!(result.contains("func encode(_writer) -> void:"));
        assert!(result.contains("static func decode(_reader):"));
        assert!(result.contains("pass  # TODO: Implement serialization"));
        assert!(result.contains("return null  # TODO: Implement deserialization"));
    }
}
