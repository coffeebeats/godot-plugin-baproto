use baproto::{CodeWriter, StringWriter, Writer};

use crate::gdscript::collect::TypeEntry;

/* -------------------------------------------------------------------------- */
/*                           Fn: generate_namespace                           */
/* -------------------------------------------------------------------------- */

/// `generate_namespace` generates the mod.gd namespace file for a package.
///
/// The namespace file provides preloads for all types in the package and
/// subpackages, allowing users to import the entire package with a single
/// preload.
pub fn generate_namespace(
    cw: &mut CodeWriter,
    pkg_name: &str,
    entries: &[TypeEntry],
    subpackages: &[String],
) -> anyhow::Result<String> {
    let mut w = StringWriter::default();

    // Header comment.
    cw.comment(&mut w, "DO NOT EDIT: Generated by 'baproto-gdscript'.")?;
    cw.blank_line(&mut w)?;

    // Package doc comment.
    let display_name = if pkg_name.is_empty() {
        "Root namespace"
    } else {
        pkg_name
    };
    cw.comment(&mut w, &format!("`{}` namespace.", display_name))?;
    cw.blank_line(&mut w)?;

    // Extends RefCounted.
    cw.writeln(&mut w, "extends Object")?;
    cw.blank_line(&mut w)?;

    // Packages section (subpackages).
    if !subpackages.is_empty() {
        write_packages_section(cw, &mut w, subpackages)?;
    }

    // Types section.
    if !entries.is_empty() {
        write_types_section(cw, &mut w, entries)?;
    }

    // Engine methods section (non-instantiable).
    let instantiable_name = if pkg_name.is_empty() {
        "root namespace"
    } else {
        pkg_name
    };
    write_engine_methods_section(cw, &mut w, instantiable_name)?;

    Ok(w.into_content())
}

/* ----------------------- Fn: write_packages_section ----------------------- */

/// `write_packages_section` writes the subpackage preloads section.
fn write_packages_section<W: Writer>(
    cw: &mut CodeWriter,
    w: &mut W,
    subpackages: &[String],
) -> anyhow::Result<()> {
    cw.comment(
        w,
        "-- PACKAGES ------------------------------------------------------------------------ #",
    )?;
    cw.blank_line(w)?;

    for subpkg in subpackages {
        cw.writeln(
            w,
            &format!("const {} := preload(\"./{}/mod.gd\")", subpkg, subpkg),
        )?;
    }

    cw.blank_line(w)?;
    Ok(())
}

/* ------------------------- Fn: write_types_section ------------------------ */

/// `write_types_section` writes the types preloads section.
fn write_types_section<W: Writer>(
    cw: &mut CodeWriter,
    w: &mut W,
    entries: &[TypeEntry],
) -> anyhow::Result<()> {
    cw.comment(
        w,
        "-- TYPES --------------------------------------------------------------------------- #",
    )?;
    cw.blank_line(w)?;

    for entry in entries {
        cw.writeln(
            w,
            &format!(
                "const {} := preload(\"./{}.gd\")",
                entry.file_stem,
                entry.file_stem.to_lowercase()
            ),
        )?;
    }

    cw.blank_line(w)?;
    Ok(())
}

/* -------------------- Fn: write_engine_methods_section -------------------- */

/// `write_engine_methods_section` writes the _init method that prevents instantiation.
fn write_engine_methods_section<W: Writer>(
    cw: &mut CodeWriter,
    w: &mut W,
    pkg_name: &str,
) -> anyhow::Result<()> {
    cw.comment(
        w,
        "-- ENGINE METHODS (OVERRIDES) ------------------------------------------------------ #",
    )?;
    cw.blank_line(w)?;

    cw.writeln(w, "func _init() -> void:")?;
    cw.indent();
    cw.writeln(
        w,
        &format!("assert(false, \"{} is non-instantiable\")", pkg_name),
    )?;
    cw.outdent();

    Ok(())
}

/* -------------------------------------------------------------------------- */
/*                                 Mod: Tests                                 */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use crate::gdscript::collect::TypeKind;
    use crate::gdscript::tests::create_code_writer;
    use baproto::{DescriptorBuilder, Encoding, Message, NativeType, PackageName, WireFormat};

    /* ---------------------- Tests: generate_namespace --------------------- */

    #[test]
    fn test_generate_empty_namespace() {
        // Given: An empty package.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game.player", &entries, &subpackages).unwrap();

        // Then: Output should contain header and package name.
        assert!(result.contains("## DO NOT EDIT: Generated by 'baproto-gdscript'."));
        assert!(result.contains("## `game.player` namespace."));
        assert!(result.contains("extends Object"));
        assert!(result.contains("game.player is non-instantiable"));
    }

    #[test]
    fn test_generate_namespace_with_types() {
        // Given: A package with types.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player".to_string(),
                simple_name: "Player".to_string(),
                nested: vec![],
            },
            TypeEntry {
                kind: TypeKind::Enum(baproto::Enum {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["State".to_string()])
                        .build()
                        .unwrap(),
                    discriminant: Encoding {
                        wire: WireFormat::Bits { count: 8 },
                        native: NativeType::Int {
                            bits: 8,
                            signed: false,
                        },
                        transforms: vec![],
                        padding_bits: None,
                    },
                    doc: None,
                    variants: vec![],
                }),
                file_stem: "State".to_string(),
                simple_name: "State".to_string(),
                nested: vec![],
            },
        ];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game", &entries, &subpackages).unwrap();

        // Then: Output should contain type preloads.
        assert!(result.contains("const Player := preload(\"./Player.gd\")"));
        assert!(result.contains("const State := preload(\"./State.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_nested_types() {
        // Given: A package with nested types.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player".to_string(),
                simple_name: "Player".to_string(),
                nested: vec!["Player_Stats".to_string()],
            },
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string(), "Stats".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player_Stats".to_string(),
                simple_name: "Stats".to_string(),
                nested: vec![],
            },
        ];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game", &entries, &subpackages).unwrap();

        // Then: Output should contain all type preloads including nested.
        assert!(result.contains("const Player := preload(\"./Player.gd\")"));
        assert!(result.contains("const Player_Stats := preload(\"./Player_Stats.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_subpackages() {
        // Given: A package with subpackages.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages = vec!["player".to_string(), "enemy".to_string()];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game", &entries, &subpackages).unwrap();

        // Then: Output should contain subpackage preloads.
        assert!(result.contains("-- PACKAGES"));
        assert!(result.contains("const player := preload(\"./player/mod.gd\")"));
        assert!(result.contains("const enemy := preload(\"./enemy/mod.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_types_and_subpackages() {
        // Given: A package with both types and subpackages.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![TypeEntry {
            kind: TypeKind::Message(Message {
                descriptor: DescriptorBuilder::default()
                    .package(pkg_name.clone())
                    .path(vec!["Common".to_string()])
                    .build()
                    .unwrap(),
                doc: None,
                fields: vec![],
                messages: vec![],
                enums: vec![],
            }),
            file_stem: "Common".to_string(),
            simple_name: "Common".to_string(),
            nested: vec![],
        }];
        let subpackages = vec!["player".to_string()];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game", &entries, &subpackages).unwrap();

        // Then: Output should contain both subpackage and type preloads.
        assert!(result.contains("const player := preload(\"./player/mod.gd\")"));
        assert!(result.contains("const Common := preload(\"./Common.gd\")"));
        // PACKAGES should come before TYPES.
        let packages_pos = result.find("-- PACKAGES").unwrap();
        let types_pos = result.find("-- TYPES").unwrap();
        assert!(packages_pos < types_pos);
    }

    #[test]
    fn test_generate_root_namespace() {
        // Given: Root namespace with top-level packages.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages = vec!["game".to_string(), "ui".to_string()];

        // When: Generating the root namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "", &entries, &subpackages).unwrap();

        // Then: Output should contain root namespace marker and top-level packages.
        assert!(result.contains("## `Root namespace` namespace."));
        assert!(result.contains("const game := preload(\"./game/mod.gd\")"));
        assert!(result.contains("const ui := preload(\"./ui/mod.gd\")"));
        assert!(result.contains("root namespace is non-instantiable"));
    }
}
