use baproto::{CodeWriter, StringWriter};

use crate::gdscript::ast::*;
use crate::gdscript::collect::TypeEntry;

/* -------------------------------------------------------------------------- */
/*                           Fn: generate_namespace                           */
/* -------------------------------------------------------------------------- */

/// `generate_namespace` generates the mod.gd namespace file for a package.
///
/// The namespace file provides preloads for all types in the package and
/// subpackages, allowing users to import the entire package with a single
/// preload.
pub fn generate_namespace(
    cw: &mut CodeWriter,
    pkg_name: &str,
    class_name: Option<&str>,
    entries: &[TypeEntry],
    subpackages: &[String],
) -> anyhow::Result<String> {
    let mut w = StringWriter::default();

    let name = if pkg_name.is_empty() {
        "Root"
    } else {
        pkg_name
    };

    let mut sections = Vec::new();

    if !subpackages.is_empty() {
        sections.push(gen_dependencies(subpackages));
    }

    if !entries.is_empty() {
        sections.push(gen_types(entries));
    }

    sections.push(gen_engine_overrides(name));

    let script = ScriptBuilder::default()
        .header(Comment::do_not_edit())
        .class_name(class_name.map(|s| s.to_owned()))
        .comment(Some(Comment::from("`{}` namespace.")))
        .extends("Object")
        .sections(sections)
        .build()
        .unwrap();

    script.emit(cw, &mut w)?;

    Ok(w.into_content())
}

/* -------------------------- Fn: gen_dependencies -------------------------- */

fn gen_dependencies(deps: &[String]) -> Section {
    let mut items = Vec::new();

    for dep in deps {
        let assignment = Assignment::preload(dep.clone(), format!("./{}/mod.gd", dep));
        items.push(assignment.into());
    }

    SectionBuilder::default()
        .header("DEPENDENCIES")
        .body(items)
        .build()
        .unwrap()
}

/* ------------------------ Fn: gen_engine_overrides ------------------------ */

fn gen_engine_overrides(name: &str) -> Section {
    let init = FnDefBuilder::default()
        .name("_init")
        .body(vec![
            FnCall::assert(
                Literal::from(false),
                format!("{} is non-instantiable", name),
            )
            .into(),
        ])
        .build()
        .unwrap();

    SectionBuilder::default()
        .header("ENGINE METHODS (OVERRIDES)")
        .body(vec![Item::FnDef(init)])
        .build()
        .unwrap()
}

/* ------------------------------ Fn: gen_types ----------------------------- */

fn gen_types(entries: &[TypeEntry]) -> Section {
    let mut items = Vec::new();

    for entry in entries {
        items.push(
            Assignment::preload(
                entry.file_stem.clone(),
                format!("./{}.gd", entry.file_stem.to_lowercase()),
            )
            .into(),
        );
    }

    SectionBuilder::default()
        .header("TYPES")
        .body(items)
        .build()
        .unwrap()
}

/* -------------------------------------------------------------------------- */
/*                                 Mod: Tests                                 */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use crate::gdscript::{GDScript, collect::TypeKind};
    use baproto::{DescriptorBuilder, Encoding, Message, NativeType, PackageName, WireFormat};

    /* ---------------------- Tests: generate_namespace --------------------- */

    #[test]
    fn test_generate_empty_namespace() {
        // Given: An empty package.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = GDScript::writer();
        let result =
            generate_namespace(&mut cw, "game.player", None, &entries, &subpackages).unwrap();

        // Then: Output should contain header and package name.
        assert!(result.contains("## DO NOT EDIT: Generated by 'baproto-gdscript'."));
        assert!(result.contains("## `game.player` namespace."));
        assert!(result.contains("extends Object"));
        assert!(result.contains("game.player is non-instantiable"));
    }

    #[test]
    fn test_generate_namespace_with_types() {
        // Given: A package with types.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player".to_string(),
                simple_name: "Player".to_string(),
                nested: vec![],
            },
            TypeEntry {
                kind: TypeKind::Enum(baproto::Enum {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["State".to_string()])
                        .build()
                        .unwrap(),
                    discriminant: Encoding {
                        wire: WireFormat::Bits { count: 8 },
                        native: NativeType::Int {
                            bits: 8,
                            signed: false,
                        },
                        transforms: vec![],
                        padding_bits: None,
                    },
                    doc: None,
                    variants: vec![],
                }),
                file_stem: "State".to_string(),
                simple_name: "State".to_string(),
                nested: vec![],
            },
        ];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = GDScript::writer();
        let result = generate_namespace(&mut cw, "game", None, &entries, &subpackages).unwrap();

        // Then: Output should contain type preloads.
        assert!(result.contains("const Player := preload(\"./player.gd\")"));
        assert!(result.contains("const State := preload(\"./state.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_nested_types() {
        // Given: A package with nested types.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player".to_string(),
                simple_name: "Player".to_string(),
                nested: vec!["Player_Stats".to_string()],
            },
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string(), "Stats".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player_Stats".to_string(),
                simple_name: "Stats".to_string(),
                nested: vec![],
            },
        ];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = GDScript::writer();
        let result = generate_namespace(&mut cw, "game", None, &entries, &subpackages).unwrap();

        // Then: Output should contain all type preloads including nested.
        assert!(result.contains("const Player := preload(\"./player.gd\")"));
        assert!(result.contains("const Player_Stats := preload(\"./player_stats.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_subpackages() {
        // Given: A package with subpackages.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages = vec!["player".to_string(), "enemy".to_string()];

        // When: Generating the namespace.
        let mut cw = GDScript::writer();
        let result = generate_namespace(&mut cw, "game", None, &entries, &subpackages).unwrap();

        // Then: Output should contain subpackage preloads.
        assert!(result.contains("-- PACKAGES"));
        assert!(result.contains("const player := preload(\"./player/mod.gd\")"));
        assert!(result.contains("const enemy := preload(\"./enemy/mod.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_types_and_subpackages() {
        // Given: A package with both types and subpackages.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![TypeEntry {
            kind: TypeKind::Message(Message {
                descriptor: DescriptorBuilder::default()
                    .package(pkg_name.clone())
                    .path(vec!["Common".to_string()])
                    .build()
                    .unwrap(),
                doc: None,
                fields: vec![],
                messages: vec![],
                enums: vec![],
            }),
            file_stem: "Common".to_string(),
            simple_name: "Common".to_string(),
            nested: vec![],
        }];
        let subpackages = vec!["player".to_string()];

        // When: Generating the namespace.
        let mut cw = GDScript::writer();
        let result = generate_namespace(&mut cw, "game", None, &entries, &subpackages).unwrap();

        // Then: Output should contain both subpackage and type preloads.
        assert!(result.contains("const player := preload(\"./player/mod.gd\")"));
        assert!(result.contains("const Common := preload(\"./common.gd\")"));
        // PACKAGES should come before TYPES.
        let packages_pos = result.find("-- PACKAGES").unwrap();
        let types_pos = result.find("-- TYPES").unwrap();
        assert!(packages_pos < types_pos);
    }

    #[test]
    fn test_generate_root_namespace() {
        // Given: Root namespace with top-level packages.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages = vec!["game".to_string(), "ui".to_string()];

        // When: Generating the root namespace.
        let mut cw = GDScript::writer();
        let result = generate_namespace(&mut cw, "", None, &entries, &subpackages).unwrap();

        // Then: Output should contain root namespace marker and top-level packages.
        assert!(result.contains("## `Root namespace` namespace."));
        assert!(result.contains("const game := preload(\"./game/mod.gd\")"));
        assert!(result.contains("const ui := preload(\"./ui/mod.gd\")"));
        assert!(result.contains("root namespace is non-instantiable"));
    }
}
