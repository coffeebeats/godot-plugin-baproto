use baproto::{CodeWriter, StringWriter};

use crate::gdscript::ast::{Emit, FuncDeclBuilder, GDFileBuilder, Item, SectionBuilder, Stmt};
use crate::gdscript::collect::TypeEntry;

/* -------------------------------------------------------------------------- */
/*                           Fn: generate_namespace                           */
/* -------------------------------------------------------------------------- */

/// `generate_namespace` generates the mod.gd namespace file for a package.
///
/// The namespace file provides preloads for all types in the package and
/// subpackages, allowing users to import the entire package with a single
/// preload.
pub fn generate_namespace(
    cw: &mut CodeWriter,
    pkg_name: &str,
    class_name: Option<&str>,
    entries: &[TypeEntry],
    subpackages: &[String],
) -> anyhow::Result<String> {
    let mut w = StringWriter::default();

    // Determine display name for documentation.
    let display_name = if pkg_name.is_empty() {
        "Root namespace"
    } else {
        pkg_name
    };

    // Determine instantiable name for error message.
    let instantiable_name = if pkg_name.is_empty() {
        "root namespace"
    } else {
        pkg_name
    };

    // Build sections.
    let mut sections = Vec::new();

    // PACKAGES section (subpackages).
    if !subpackages.is_empty() {
        let mut items = Vec::new();
        for subpkg in subpackages {
            items.push(Item::Stmt(Stmt::Preload {
                name: subpkg.clone(),
                path: format!("./{}/mod.gd", subpkg),
            }));
        }

        sections.push(
            SectionBuilder::default()
                .name("PACKAGES")
                .body(items)
                .build()?,
        );
    }

    // TYPES section.
    if !entries.is_empty() {
        let mut items = Vec::new();
        for entry in entries {
            items.push(Item::Stmt(Stmt::Preload {
                name: entry.file_stem.clone(),
                path: format!("./{}.gd", entry.file_stem.to_lowercase()),
            }));
        }

        sections.push(
            SectionBuilder::default()
                .name("TYPES")
                .body(items)
                .build()?,
        );
    }

    // ENGINE METHODS section (non-instantiable).
    let init_func = FuncDeclBuilder::default()
        .name("_init")
        .return_type("void")
        .body(vec![Stmt::Expr(format!(
            "assert(false, \"{} is non-instantiable\")",
            instantiable_name
        ))])
        .build()?;

    sections.push(
        SectionBuilder::default()
            .name("ENGINE METHODS (OVERRIDES)")
            .body(vec![Item::Func(init_func)])
            .build()?,
    );

    // Build the GDScript file.
    let mut builder = GDFileBuilder::default();
    builder
        .header_comment("DO NOT EDIT: Generated by 'baproto-gdscript'.")
        .doc(format!("`{}` namespace.", display_name))
        .extends("Object")
        .sections(sections);

    if let Some(cn) = class_name {
        builder.class_name(cn);
    }

    let file = builder.build()?;

    // Emit the file.
    file.emit(cw, &mut w)?;

    Ok(w.into_content())
}

/* -------------------------------------------------------------------------- */
/*                                 Mod: Tests                                 */
/* -------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;
    use crate::gdscript::collect::TypeKind;
    use crate::gdscript::tests::create_code_writer;
    use baproto::{DescriptorBuilder, Encoding, Message, NativeType, PackageName, WireFormat};

    /* ---------------------- Tests: generate_namespace --------------------- */

    #[test]
    fn test_generate_empty_namespace() {
        // Given: An empty package.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result =
            generate_namespace(&mut cw, "game.player", None, &entries, &subpackages).unwrap();

        // Then: Output should contain header and package name.
        assert!(result.contains("## DO NOT EDIT: Generated by 'baproto-gdscript'."));
        assert!(result.contains("## `game.player` namespace."));
        assert!(result.contains("extends Object"));
        assert!(result.contains("game.player is non-instantiable"));
    }

    #[test]
    fn test_generate_namespace_with_types() {
        // Given: A package with types.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player".to_string(),
                simple_name: "Player".to_string(),
                nested: vec![],
            },
            TypeEntry {
                kind: TypeKind::Enum(baproto::Enum {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["State".to_string()])
                        .build()
                        .unwrap(),
                    discriminant: Encoding {
                        wire: WireFormat::Bits { count: 8 },
                        native: NativeType::Int {
                            bits: 8,
                            signed: false,
                        },
                        transforms: vec![],
                        padding_bits: None,
                    },
                    doc: None,
                    variants: vec![],
                }),
                file_stem: "State".to_string(),
                simple_name: "State".to_string(),
                nested: vec![],
            },
        ];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game", None, &entries, &subpackages).unwrap();

        // Then: Output should contain type preloads.
        assert!(result.contains("const Player := preload(\"./player.gd\")"));
        assert!(result.contains("const State := preload(\"./state.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_nested_types() {
        // Given: A package with nested types.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player".to_string(),
                simple_name: "Player".to_string(),
                nested: vec!["Player_Stats".to_string()],
            },
            TypeEntry {
                kind: TypeKind::Message(Message {
                    descriptor: DescriptorBuilder::default()
                        .package(pkg_name.clone())
                        .path(vec!["Player".to_string(), "Stats".to_string()])
                        .build()
                        .unwrap(),
                    doc: None,
                    fields: vec![],
                    messages: vec![],
                    enums: vec![],
                }),
                file_stem: "Player_Stats".to_string(),
                simple_name: "Stats".to_string(),
                nested: vec![],
            },
        ];
        let subpackages: Vec<String> = vec![];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game", None, &entries, &subpackages).unwrap();

        // Then: Output should contain all type preloads including nested.
        assert!(result.contains("const Player := preload(\"./player.gd\")"));
        assert!(result.contains("const Player_Stats := preload(\"./player_stats.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_subpackages() {
        // Given: A package with subpackages.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages = vec!["player".to_string(), "enemy".to_string()];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game", None, &entries, &subpackages).unwrap();

        // Then: Output should contain subpackage preloads.
        assert!(result.contains("-- PACKAGES"));
        assert!(result.contains("const player := preload(\"./player/mod.gd\")"));
        assert!(result.contains("const enemy := preload(\"./enemy/mod.gd\")"));
    }

    #[test]
    fn test_generate_namespace_with_types_and_subpackages() {
        // Given: A package with both types and subpackages.
        let pkg_name = PackageName::try_from(vec!["game"]).unwrap();
        let entries = vec![TypeEntry {
            kind: TypeKind::Message(Message {
                descriptor: DescriptorBuilder::default()
                    .package(pkg_name.clone())
                    .path(vec!["Common".to_string()])
                    .build()
                    .unwrap(),
                doc: None,
                fields: vec![],
                messages: vec![],
                enums: vec![],
            }),
            file_stem: "Common".to_string(),
            simple_name: "Common".to_string(),
            nested: vec![],
        }];
        let subpackages = vec!["player".to_string()];

        // When: Generating the namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "game", None, &entries, &subpackages).unwrap();

        // Then: Output should contain both subpackage and type preloads.
        assert!(result.contains("const player := preload(\"./player/mod.gd\")"));
        assert!(result.contains("const Common := preload(\"./common.gd\")"));
        // PACKAGES should come before TYPES.
        let packages_pos = result.find("-- PACKAGES").unwrap();
        let types_pos = result.find("-- TYPES").unwrap();
        assert!(packages_pos < types_pos);
    }

    #[test]
    fn test_generate_root_namespace() {
        // Given: Root namespace with top-level packages.
        let entries: Vec<TypeEntry> = vec![];
        let subpackages = vec!["game".to_string(), "ui".to_string()];

        // When: Generating the root namespace.
        let mut cw = create_code_writer();
        let result = generate_namespace(&mut cw, "", None, &entries, &subpackages).unwrap();

        // Then: Output should contain root namespace marker and top-level packages.
        assert!(result.contains("## `Root namespace` namespace."));
        assert!(result.contains("const game := preload(\"./game/mod.gd\")"));
        assert!(result.contains("const ui := preload(\"./ui/mod.gd\")"));
        assert!(result.contains("root namespace is non-instantiable"));
    }
}
